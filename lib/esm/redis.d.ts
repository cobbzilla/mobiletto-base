import Redis from "ioredis";
import { Cacheable, CacheLike } from "./cache.js";
export declare const REDIS_HOST: string;
export declare const REDIS_PORT: string | number;
export declare const REDIS_PREFIX: string;
export declare const getRedis: (name: string, host: string, port: number, prefix: string) => MobilettoCache;
type CacheCounters = {
    get: number;
    set: number;
    del: number;
    flush: number;
    hit: number;
    miss: number;
};
export declare class MobilettoCache implements CacheLike {
    readonly name: string;
    redis: Redis | null;
    readonly prefix: string;
    readonly scopedCaches: Record<string, CacheLike>;
    counters: CacheCounters;
    printStatsInterval: number;
    constructor(name: string, host?: string, port?: number, prefix?: string);
    disconnect: () => void;
    stats: () => CacheCounters;
    resetStats: () => void;
    hitRate: () => number;
    toString: () => string;
    pfx: (key: string) => string;
    unprefix: (key: string) => string;
    doRedisAsync: <T>(func: (redis: Redis) => Promise<T>, defaultValue?: T | null) => Promise<T | null>;
    doRedis: <T>(func: (redis: Redis) => T, defaultValue?: T | null) => T | null;
    get: <T>(key: string) => Promise<T | null | undefined>;
    set: (key: string, val: Cacheable, expirationMillis?: number) => Promise<void>;
    del: (key: string) => Promise<void>;
    scan: <T>(pattern: string, callback?: ((key: string) => Promise<T>) | undefined, endCallback?: ((count: number) => Promise<unknown>) | undefined) => Promise<T[]>;
    findMatchingKeys: (pattern: string) => Promise<string[]>;
    applyToMatchingKeys: <T>(pattern: string, asyncFunc: (key: string) => Promise<T>) => Promise<T[]>;
    removeMatchingKeys: (pattern: string) => Promise<void[]>;
    flush: () => Promise<void>;
    scopedCache: (name: string, size?: number) => CacheLike;
}
export declare const teardown: () => Promise<undefined[]>;
export declare const flushAll: () => Promise<void[]>;
export {};
